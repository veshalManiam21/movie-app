"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = exports.transitionPropertyTransformer = exports.transitionTimingFunctionTransformer = exports.transitionDelayTransformer = exports.transitionDurationTransformer = void 0;
var css_to_react_native_1 = __importDefault(require("css-to-react-native"));
var parsers_1 = require("./parsers");
var constants_1 = require("./constants");
var boxShadowTransformer = function (decl) {
    var prop = decl[0], value = decl[1];
    var _a = parsers_1.parse(prop, value), parsed = _a.parsed, meta = _a.meta;
    var transformed = css_to_react_native_1.default([[prop, parsed]]);
    // Estimate the Android elevation
    // This can be improved
    var offsetX = meta.offsetX, offsetY = meta.offsetY, blurRadius = meta.blurRadius, spreadRadius = meta.spreadRadius;
    var sum = function (acc, prop) {
        return acc + parseInt("0" + prop);
    };
    var rank = [offsetX, offsetY, blurRadius, spreadRadius].reduce(sum, 0);
    var penumbraPosition = constants_1.ANDROID_PENUMBRA_MAP.findIndex(function (penumbra) {
        return penumbra.reduce(sum, 0) >= rank;
    });
    var elevation = penumbraPosition === -1
        ? constants_1.ANDROID_PENUMBRA_MAP.length - 1
        : penumbraPosition > 0
            ? penumbraPosition - 1
            : 0;
    return __assign(__assign({}, transformed), { elevation: elevation });
};
exports.transitionDurationTransformer = function (decl) {
    var prop = decl[0], value = decl[1];
    var result = /^(\d+\.?\d{0,})(s|ms)$/.exec(value);
    if (!result) {
        throw new Error("Invalid value for " + prop + ": " + value);
    }
    var number = result[1], unit = result[2];
    var newValue = unit === "ms" ? parseInt(number) : parseFloat(number) * 1000;
    return { transitionDuration: newValue };
};
exports.transitionDelayTransformer = function (decl) {
    var prop = decl[0], value = decl[1];
    var result = /^(\d+\.?\d{0,})(s|ms)$/.exec(value);
    if (!result) {
        throw new Error("Invalid value for " + prop + ": " + value);
    }
    var number = result[1], unit = result[2];
    var newValue = unit === "ms" ? parseInt(number) : parseFloat(number) * 1000;
    return { transitionDelay: newValue };
};
exports.transitionTimingFunctionTransformer = function (decl) {
    var prop = decl[0], value = decl[1];
    // Keywords
    var keywords = [
        "ease",
        "ease-in",
        "ease-out",
        "ease-in-out",
        "linear",
        "step-start",
        "step-end",
    ];
    if (keywords.includes(value)) {
        return { transitionTimingFunction: { type: value, args: [] } };
    }
    // Functions
    if (value.startsWith("cubic-bezier")) {
        var result = /^cubic-bezier\((\d+\.?\d{0,})\s*,\s*(\d+\.?\d{0,})\s*,\s*(\d+\.?\d{0,})\s*,\s*(\d+\.?\d{0,})\)$/.exec(value);
        if (!result)
            throw new Error("Invalid value for " + prop + ": " + value);
        var x1 = result[1], y1 = result[2], x2 = result[3], y2 = result[4];
        return {
            transitionTimingFunction: {
                type: "bezier",
                args: [parseFloat(x1), parseFloat(y1), parseFloat(x2), parseFloat(y2)],
            },
        };
    }
    throw new Error("Transition timing function not supported " + prop + ": " + value);
};
exports.transitionPropertyTransformer = function (decl) {
    var prop = decl[0], value = decl[1];
    if (value.match(/none/)) {
        return { transitionProperty: [] };
    }
    return { transitionProperty: value.split(/\s{0,},\s{0,}/) };
};
var transformersMap = {
    "box-shadow": boxShadowTransformer,
    "transition-duration": exports.transitionDurationTransformer,
    "transition-delay": exports.transitionDelayTransformer,
    "transition-timing-function": exports.transitionTimingFunctionTransformer,
    "transition-property": exports.transitionPropertyTransformer,
};
exports.transform = function (decls) {
    var _a = decls.reduce(function (_a, decl) {
        var defaultDecls = _a[0], specificDecls = _a[1];
        var prop = decl[0];
        if (transformersMap[prop] !== undefined) {
            return [defaultDecls, __spreadArrays(specificDecls, [decl])];
        }
        return [__spreadArrays(defaultDecls, [decl]), specificDecls];
    }, [[], []]), defaultDecls = _a[0], specificDecls = _a[1];
    var defaultTransformed = css_to_react_native_1.default(defaultDecls);
    var specificTransformed = specificDecls
        .map(function (decl) {
        var transform = transformersMap[decl[0]];
        return transform(decl);
    })
        .reduce(function (acc, transformed) {
        return __assign(__assign({}, acc), transformed);
    }, {});
    return __assign(__assign({}, defaultTransformed), specificTransformed);
};
//# sourceMappingURL=transformers.js.map