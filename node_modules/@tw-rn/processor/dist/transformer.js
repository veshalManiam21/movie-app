"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.transform = void 0;
var css_to_react_native_1 = __importDefault(require("css-to-react-native"));
var parsers_1 = require("./parsers");
var constants_1 = require("./constants");
var boxShadowTransformer = function (decl) {
    var prop = decl[0], value = decl[1];
    var _a = parsers_1.parse(prop, value), parsed = _a.parsed, meta = _a.meta;
    var transformed = css_to_react_native_1.default([[prop, parsed]]);
    // Estimate the Android elevation
    // This can be improved
    var offsetX = meta.offsetX, offsetY = meta.offsetY, blurRadius = meta.blurRadius, spreadRadius = meta.spreadRadius;
    var sum = function (acc, prop) { return acc + parseInt("0" + prop); };
    var rank = [offsetX, offsetY, blurRadius, spreadRadius].reduce(sum, 0);
    var penumbraPosition = constants_1.ANDROID_PENUMBRA_MAP.findIndex(function (penumbra) {
        return penumbra.reduce(sum, 0) >= rank;
    });
    var elevation = penumbraPosition === -1
        ? constants_1.ANDROID_PENUMBRA_MAP.length - 1
        : penumbraPosition > 0
            ? penumbraPosition - 1
            : 0;
    return __assign(__assign({}, transformed), { elevation: elevation });
};
var transformersMap = {
    "box-shadow": boxShadowTransformer,
};
exports.transform = function (decls) {
    var _a = decls.reduce(function (_a, decl) {
        var defaultDecls = _a[0], specificDecls = _a[1];
        var prop = decl[0];
        if (transformersMap[prop] !== undefined) {
            return [defaultDecls, __spreadArrays(specificDecls, [decl])];
        }
        return [__spreadArrays(defaultDecls, [decl]), specificDecls];
    }, [[], []]), defaultDecls = _a[0], specificDecls = _a[1];
    var defaultTransformed = css_to_react_native_1.default(defaultDecls);
    var specificTransformed = specificDecls
        .map(function (decl) {
        var transform = transformersMap[decl[0]];
        return transform(decl);
    })
        .reduce(function (acc, transformed) {
        return __assign(__assign({}, acc), transformed);
    }, {});
    return __assign(__assign({}, defaultTransformed), specificTransformed);
};
//# sourceMappingURL=transformer.js.map