{"version":3,"sources":["useAnimationStyles.ts"],"names":["Animated","Easing","useMemo","useCallback","useRef","ANIMATION_CONFIG_STYLE_PROPS","getDefaultStyleValueFunction","useAnimationStyles","combinedStyles","animatedValuesRef","createAnimatedValueIfDoesntExist","mapIndex","styleName","current","animatedValue","Value","interpolations","interpolatedValues","listenerId","addListener","newInterpolatedValues","map","i","__getValue","animateStyle","config","values","toValue","duration","timingFunction","delay","type","args","easing","bezier","linear","length","stopAnimation","console","log","from","to","interpolation","interpolate","inputRange","outputRange","setValue","timing","useNativeDriver","start","defaultValue","transformStyles","style","transitionProperty","transitionDuration","transitionTimingFunction","transitionDelay","restStyles","restStylesKeys","Object","keys","animatedStyles","reduce","acc","prop","regex","RegExp","split","join","styleNamesToAnimate","filter","key","exec","stylesAnimatedValues","value","requiresAnimatedComponent","some","combinedStyle","includes","regularOrAnimatedStyles","index"],"mappings":"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","sourcesContent":["import { Animated, Easing } from \"react-native\";\nimport { useMemo, useCallback, useRef, useEffect } from \"react\";\nimport { Style, StyleValue } from \"../types\";\nimport { ANIMATION_CONFIG_STYLE_PROPS } from \"../constants\";\nimport { dashToCamelCase } from \"../helpers/string\";\nimport { getDefaultStyleValueFunction } from \"../helpers/animated\";\n\ntype AnimatedValues = {\n  animatedValue: Animated.Value;\n  interpolations: Animated.AnimatedInterpolation[];\n  interpolatedValues: (number | string)[];\n  listenerId?: string;\n};\n\ntype AnimateValueConfig = {\n  toValue: StyleValue;\n  duration: StyleValue;\n  timingFunction: StyleValue;\n  delay: StyleValue;\n};\n\nexport const useAnimationStyles = (\n  combinedStyles: (Style | null | undefined)[]\n): {\n  requiresAnimatedComponent: boolean;\n  regularOrAnimatedStyles: typeof combinedStyles;\n} => {\n  const animatedValuesRef = useRef<{\n    [styleIndex: number]: { [key: string]: AnimatedValues };\n  }>({});\n\n  const createAnimatedValueIfDoesntExist = useCallback(\n    (mapIndex: number, styleName: string) => {\n      // Don't create if already exists\n      if (animatedValuesRef.current[mapIndex]?.[styleName]) {\n        return;\n      }\n\n      animatedValuesRef.current[mapIndex] =\n        animatedValuesRef.current[mapIndex] ?? {};\n\n      const animatedValue = new Animated.Value(0);\n\n      animatedValuesRef.current[mapIndex][styleName] = {\n        animatedValue,\n        interpolations: [],\n        interpolatedValues: [],\n      };\n\n      // Adding the listener for tracking\n      const listenerId = animatedValue.addListener(() => {\n        const { interpolations } = animatedValuesRef.current[mapIndex][\n          styleName\n        ];\n        const newInterpolatedValues = interpolations.map((i) =>\n          (i as any).__getValue()\n        );\n\n        animatedValuesRef.current[mapIndex][styleName][\n          \"interpolatedValues\"\n        ] = newInterpolatedValues;\n      });\n\n      animatedValuesRef.current[mapIndex][styleName][\"listenerId\"] = listenerId;\n    },\n    [animatedValuesRef]\n  );\n\n  const animateStyle = useCallback(\n    (\n      mapIndex: number,\n      styleName: string,\n\n      config: AnimateValueConfig\n    ): Animated.AnimatedInterpolation => {\n      createAnimatedValueIfDoesntExist(mapIndex, styleName);\n\n      const values = animatedValuesRef.current[mapIndex]?.[styleName];\n      const { animatedValue, interpolations, interpolatedValues } = values;\n      const { toValue, duration = 0, timingFunction = {}, delay = 0 } = config;\n\n      const { type = \"linear\", args = [] } = timingFunction as any;\n\n      const easing =\n        type === \"bezier\"\n          ? Easing.bezier(args[0], args[1], args[2], args[3])\n          : Easing.linear;\n\n      // Check if this value has any interpolation\n      if (interpolations.length) {\n        animatedValue.stopAnimation();\n\n        console.log({ from: interpolatedValues[0], to: toValue });\n\n        const interpolation = animatedValue.interpolate({\n          inputRange: [0, 1],\n          outputRange: [interpolatedValues[0], toValue as any],\n        });\n\n        animatedValue.setValue(0);\n\n        Animated.timing(animatedValue, {\n          toValue: 1,\n          duration: duration as number,\n          easing,\n          delay: delay as number,\n          useNativeDriver: true,\n        }).start();\n\n        animatedValuesRef.current[mapIndex][styleName][\"interpolations\"] = [\n          interpolation,\n          // interpolatedValues: []\n        ];\n\n        return interpolation;\n        // Check if is a shadow... (2 interpolations)\n      }\n\n      // We don't animate beause is the first mount, applying default values\n      const defaultValue = getDefaultStyleValueFunction(styleName)(toValue);\n\n      // Check if is object\n\n      // Create a new interpolation\n      const interpolation = animatedValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [toValue as any, defaultValue as any],\n      });\n\n      animatedValuesRef.current[mapIndex][styleName][\"interpolations\"] = [\n        interpolation,\n      ];\n\n      animatedValuesRef.current[mapIndex][styleName][\"interpolatedValues\"] = [\n        toValue as any,\n      ];\n\n      return interpolation;\n    },\n    []\n  );\n\n  const transformStyles = useCallback(\n    (mapIndex: number, style: Style): Style => {\n      const {\n        transitionProperty,\n        transitionDuration,\n        transitionTimingFunction,\n        transitionDelay,\n        ...restStyles\n      } = style;\n\n      const restStylesKeys = Object.keys(restStyles);\n\n      const animatedStyles = (transitionProperty as string[]).reduce(\n        (acc, prop) => {\n          // Get the styles to animate for this prop\n          // NOTE: can be wrong so this needs to be tested exahustively\n          const regex = new RegExp(`^${prop.split(\"-\").join(\".*\")}.*$`, \"i\");\n          const styleNamesToAnimate = restStylesKeys.filter((key) => {\n            return regex.exec(key);\n          });\n\n          const stylesAnimatedValues = styleNamesToAnimate.reduce(\n            (acc, styleName) => {\n              const config = {\n                toValue: restStyles[styleName],\n                duration: transitionDuration,\n                timingFunction: transitionTimingFunction,\n                delay: transitionDelay,\n              };\n\n              const value = animateStyle(mapIndex, styleName, config);\n\n              return { ...acc, [styleName]: value };\n            },\n            {}\n          );\n          return { ...acc, ...stylesAnimatedValues };\n        },\n        {}\n      );\n      return { ...restStyles, ...animatedStyles };\n    },\n    []\n  );\n\n  const requiresAnimatedComponent = useMemo(\n    () =>\n      combinedStyles.some((combinedStyle) => {\n        if (combinedStyle) {\n          return Object.keys(combinedStyle).some((key) =>\n            ANIMATION_CONFIG_STYLE_PROPS.includes(key as any)\n          );\n        }\n\n        return false;\n      }),\n    [combinedStyles]\n  );\n\n  const regularOrAnimatedStyles = useMemo(() => {\n    if (!requiresAnimatedComponent) return combinedStyles;\n\n    return combinedStyles.map((combinedStyle, index) => {\n      return combinedStyle\n        ? transformStyles(index, combinedStyle)\n        : combinedStyle;\n    });\n  }, [animatedValuesRef, combinedStyles, requiresAnimatedComponent]);\n\n  return { requiresAnimatedComponent, regularOrAnimatedStyles };\n};\n"]}