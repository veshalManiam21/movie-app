"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAnimationStyles = void 0;

var _reactNative = require("react-native");

var _react = require("react");

var _constants = require("../constants");

var _animated = require("../helpers/animated");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const useAnimationStyles = combinedStyles => {
  const animatedValuesRef = (0, _react.useRef)({});
  const createAnimatedValueIfDoesntExist = (0, _react.useCallback)((mapIndex, styleName) => {
    var _animatedValuesRef$cu, _animatedValuesRef$cu2;

    // Don't create if already exists
    if ((_animatedValuesRef$cu = animatedValuesRef.current[mapIndex]) === null || _animatedValuesRef$cu === void 0 ? void 0 : _animatedValuesRef$cu[styleName]) {
      return;
    }

    animatedValuesRef.current[mapIndex] = (_animatedValuesRef$cu2 = animatedValuesRef.current[mapIndex]) !== null && _animatedValuesRef$cu2 !== void 0 ? _animatedValuesRef$cu2 : {};
    const animatedValue = new _reactNative.Animated.Value(0);
    animatedValuesRef.current[mapIndex][styleName] = {
      animatedValue,
      interpolations: [],
      interpolatedValues: []
    }; // Adding the listener for tracking

    const listenerId = animatedValue.addListener(() => {
      const {
        interpolations
      } = animatedValuesRef.current[mapIndex][styleName];
      const newInterpolatedValues = interpolations.map(i => i.__getValue());
      animatedValuesRef.current[mapIndex][styleName]["interpolatedValues"] = newInterpolatedValues;
    });
    animatedValuesRef.current[mapIndex][styleName]["listenerId"] = listenerId;
  }, [animatedValuesRef]);
  const animateStyle = (0, _react.useCallback)((mapIndex, styleName, config) => {
    var _animatedValuesRef$cu3;

    createAnimatedValueIfDoesntExist(mapIndex, styleName);
    const values = (_animatedValuesRef$cu3 = animatedValuesRef.current[mapIndex]) === null || _animatedValuesRef$cu3 === void 0 ? void 0 : _animatedValuesRef$cu3[styleName];
    const {
      animatedValue,
      interpolations,
      interpolatedValues
    } = values;
    const {
      toValue,
      duration = 0,
      timingFunction = {},
      delay = 0
    } = config;
    const {
      type = "linear",
      args = []
    } = timingFunction;
    const easing = type === "bezier" ? _reactNative.Easing.bezier(args[0], args[1], args[2], args[3]) : _reactNative.Easing.linear; // Check if this value has any interpolation

    if (interpolations.length) {
      animatedValue.stopAnimation();
      console.log({
        from: interpolatedValues[0],
        to: toValue
      });
      const interpolation = animatedValue.interpolate({
        inputRange: [0, 1],
        outputRange: [interpolatedValues[0], toValue]
      });
      animatedValue.setValue(0);

      _reactNative.Animated.timing(animatedValue, {
        toValue: 1,
        duration: duration,
        easing,
        delay: delay,
        useNativeDriver: true
      }).start();

      animatedValuesRef.current[mapIndex][styleName]["interpolations"] = [interpolation // interpolatedValues: []
      ];
      return interpolation; // Check if is a shadow... (2 interpolations)
    } // We don't animate beause is the first mount, applying default values


    const defaultValue = (0, _animated.getDefaultStyleValueFunction)(styleName)(toValue); // Check if is object
    // Create a new interpolation

    const interpolation = animatedValue.interpolate({
      inputRange: [0, 1],
      outputRange: [toValue, defaultValue]
    });
    animatedValuesRef.current[mapIndex][styleName]["interpolations"] = [interpolation];
    animatedValuesRef.current[mapIndex][styleName]["interpolatedValues"] = [toValue];
    return interpolation;
  }, []);
  const transformStyles = (0, _react.useCallback)((mapIndex, style) => {
    const {
      transitionProperty,
      transitionDuration,
      transitionTimingFunction,
      transitionDelay
    } = style,
          restStyles = _objectWithoutProperties(style, ["transitionProperty", "transitionDuration", "transitionTimingFunction", "transitionDelay"]);

    const restStylesKeys = Object.keys(restStyles);
    const animatedStyles = transitionProperty.reduce((acc, prop) => {
      // Get the styles to animate for this prop
      // NOTE: can be wrong so this needs to be tested exahustively
      const regex = new RegExp("^".concat(prop.split("-").join(".*"), ".*$"), "i");
      const styleNamesToAnimate = restStylesKeys.filter(key => {
        return regex.exec(key);
      });
      const stylesAnimatedValues = styleNamesToAnimate.reduce((acc, styleName) => {
        const config = {
          toValue: restStyles[styleName],
          duration: transitionDuration,
          timingFunction: transitionTimingFunction,
          delay: transitionDelay
        };
        const value = animateStyle(mapIndex, styleName, config);
        return _objectSpread(_objectSpread({}, acc), {}, {
          [styleName]: value
        });
      }, {});
      return _objectSpread(_objectSpread({}, acc), stylesAnimatedValues);
    }, {});
    return _objectSpread(_objectSpread({}, restStyles), animatedStyles);
  }, []);
  const requiresAnimatedComponent = (0, _react.useMemo)(() => combinedStyles.some(combinedStyle => {
    if (combinedStyle) {
      return Object.keys(combinedStyle).some(key => _constants.ANIMATION_CONFIG_STYLE_PROPS.includes(key));
    }

    return false;
  }), [combinedStyles]);
  const regularOrAnimatedStyles = (0, _react.useMemo)(() => {
    if (!requiresAnimatedComponent) return combinedStyles;
    return combinedStyles.map((combinedStyle, index) => {
      return combinedStyle ? transformStyles(index, combinedStyle) : combinedStyle;
    });
  }, [animatedValuesRef, combinedStyles, requiresAnimatedComponent]);
  return {
    requiresAnimatedComponent,
    regularOrAnimatedStyles
  };
};

exports.useAnimationStyles = useAnimationStyles;
//# sourceMappingURL=useAnimationStyles.js.map