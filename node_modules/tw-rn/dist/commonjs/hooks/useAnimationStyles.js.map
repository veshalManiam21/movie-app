{"version":3,"sources":["useAnimationStyles.ts"],"names":["useAnimationStyles","combinedStyles","animatedValuesRef","createAnimatedValueIfDoesntExist","mapIndex","styleName","current","animatedValue","Animated","Value","interpolations","interpolatedValues","listenerId","addListener","newInterpolatedValues","map","i","__getValue","animateStyle","config","values","toValue","duration","timingFunction","delay","type","args","easing","Easing","bezier","linear","length","stopAnimation","console","log","from","to","interpolation","interpolate","inputRange","outputRange","setValue","timing","useNativeDriver","start","defaultValue","transformStyles","style","transitionProperty","transitionDuration","transitionTimingFunction","transitionDelay","restStyles","restStylesKeys","Object","keys","animatedStyles","reduce","acc","prop","regex","RegExp","split","join","styleNamesToAnimate","filter","key","exec","stylesAnimatedValues","value","requiresAnimatedComponent","some","combinedStyle","ANIMATION_CONFIG_STYLE_PROPS","includes","regularOrAnimatedStyles","index"],"mappings":"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","sourcesContent":["import { Animated, Easing } from \"react-native\";\nimport { useMemo, useCallback, useRef, useEffect } from \"react\";\nimport { Style, StyleValue } from \"../types\";\nimport { ANIMATION_CONFIG_STYLE_PROPS } from \"../constants\";\nimport { dashToCamelCase } from \"../helpers/string\";\nimport { getDefaultStyleValueFunction } from \"../helpers/animated\";\n\ntype AnimatedValues = {\n  animatedValue: Animated.Value;\n  interpolations: Animated.AnimatedInterpolation[];\n  interpolatedValues: (number | string)[];\n  listenerId?: string;\n};\n\ntype AnimateValueConfig = {\n  toValue: StyleValue;\n  duration: StyleValue;\n  timingFunction: StyleValue;\n  delay: StyleValue;\n};\n\nexport const useAnimationStyles = (\n  combinedStyles: (Style | null | undefined)[]\n): {\n  requiresAnimatedComponent: boolean;\n  regularOrAnimatedStyles: typeof combinedStyles;\n} => {\n  const animatedValuesRef = useRef<{\n    [styleIndex: number]: { [key: string]: AnimatedValues };\n  }>({});\n\n  const createAnimatedValueIfDoesntExist = useCallback(\n    (mapIndex: number, styleName: string) => {\n      // Don't create if already exists\n      if (animatedValuesRef.current[mapIndex]?.[styleName]) {\n        return;\n      }\n\n      animatedValuesRef.current[mapIndex] =\n        animatedValuesRef.current[mapIndex] ?? {};\n\n      const animatedValue = new Animated.Value(0);\n\n      animatedValuesRef.current[mapIndex][styleName] = {\n        animatedValue,\n        interpolations: [],\n        interpolatedValues: [],\n      };\n\n      // Adding the listener for tracking\n      const listenerId = animatedValue.addListener(() => {\n        const { interpolations } = animatedValuesRef.current[mapIndex][\n          styleName\n        ];\n        const newInterpolatedValues = interpolations.map((i) =>\n          (i as any).__getValue()\n        );\n\n        animatedValuesRef.current[mapIndex][styleName][\n          \"interpolatedValues\"\n        ] = newInterpolatedValues;\n      });\n\n      animatedValuesRef.current[mapIndex][styleName][\"listenerId\"] = listenerId;\n    },\n    [animatedValuesRef]\n  );\n\n  const animateStyle = useCallback(\n    (\n      mapIndex: number,\n      styleName: string,\n\n      config: AnimateValueConfig\n    ): Animated.AnimatedInterpolation => {\n      createAnimatedValueIfDoesntExist(mapIndex, styleName);\n\n      const values = animatedValuesRef.current[mapIndex]?.[styleName];\n      const { animatedValue, interpolations, interpolatedValues } = values;\n      const { toValue, duration = 0, timingFunction = {}, delay = 0 } = config;\n\n      const { type = \"linear\", args = [] } = timingFunction as any;\n\n      const easing =\n        type === \"bezier\"\n          ? Easing.bezier(args[0], args[1], args[2], args[3])\n          : Easing.linear;\n\n      // Check if this value has any interpolation\n      if (interpolations.length) {\n        animatedValue.stopAnimation();\n\n        console.log({ from: interpolatedValues[0], to: toValue });\n\n        const interpolation = animatedValue.interpolate({\n          inputRange: [0, 1],\n          outputRange: [interpolatedValues[0], toValue as any],\n        });\n\n        animatedValue.setValue(0);\n\n        Animated.timing(animatedValue, {\n          toValue: 1,\n          duration: duration as number,\n          easing,\n          delay: delay as number,\n          useNativeDriver: true,\n        }).start();\n\n        animatedValuesRef.current[mapIndex][styleName][\"interpolations\"] = [\n          interpolation,\n          // interpolatedValues: []\n        ];\n\n        return interpolation;\n        // Check if is a shadow... (2 interpolations)\n      }\n\n      // We don't animate beause is the first mount, applying default values\n      const defaultValue = getDefaultStyleValueFunction(styleName)(toValue);\n\n      // Check if is object\n\n      // Create a new interpolation\n      const interpolation = animatedValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [toValue as any, defaultValue as any],\n      });\n\n      animatedValuesRef.current[mapIndex][styleName][\"interpolations\"] = [\n        interpolation,\n      ];\n\n      animatedValuesRef.current[mapIndex][styleName][\"interpolatedValues\"] = [\n        toValue as any,\n      ];\n\n      return interpolation;\n    },\n    []\n  );\n\n  const transformStyles = useCallback(\n    (mapIndex: number, style: Style): Style => {\n      const {\n        transitionProperty,\n        transitionDuration,\n        transitionTimingFunction,\n        transitionDelay,\n        ...restStyles\n      } = style;\n\n      const restStylesKeys = Object.keys(restStyles);\n\n      const animatedStyles = (transitionProperty as string[]).reduce(\n        (acc, prop) => {\n          // Get the styles to animate for this prop\n          // NOTE: can be wrong so this needs to be tested exahustively\n          const regex = new RegExp(`^${prop.split(\"-\").join(\".*\")}.*$`, \"i\");\n          const styleNamesToAnimate = restStylesKeys.filter((key) => {\n            return regex.exec(key);\n          });\n\n          const stylesAnimatedValues = styleNamesToAnimate.reduce(\n            (acc, styleName) => {\n              const config = {\n                toValue: restStyles[styleName],\n                duration: transitionDuration,\n                timingFunction: transitionTimingFunction,\n                delay: transitionDelay,\n              };\n\n              const value = animateStyle(mapIndex, styleName, config);\n\n              return { ...acc, [styleName]: value };\n            },\n            {}\n          );\n          return { ...acc, ...stylesAnimatedValues };\n        },\n        {}\n      );\n      return { ...restStyles, ...animatedStyles };\n    },\n    []\n  );\n\n  const requiresAnimatedComponent = useMemo(\n    () =>\n      combinedStyles.some((combinedStyle) => {\n        if (combinedStyle) {\n          return Object.keys(combinedStyle).some((key) =>\n            ANIMATION_CONFIG_STYLE_PROPS.includes(key as any)\n          );\n        }\n\n        return false;\n      }),\n    [combinedStyles]\n  );\n\n  const regularOrAnimatedStyles = useMemo(() => {\n    if (!requiresAnimatedComponent) return combinedStyles;\n\n    return combinedStyles.map((combinedStyle, index) => {\n      return combinedStyle\n        ? transformStyles(index, combinedStyle)\n        : combinedStyle;\n    });\n  }, [animatedValuesRef, combinedStyles, requiresAnimatedComponent]);\n\n  return { requiresAnimatedComponent, regularOrAnimatedStyles };\n};\n"]}